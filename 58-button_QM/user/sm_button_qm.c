/*.$file${.::sm_button_qm.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: button.qm
* File:  ${.::sm_button_qm.c}
*
* This code has been generated by QM 5.1.4 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${.::sm_button_qm.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "sm_button_qm.h"
#include "event_def.h"
#include "button.h"
#include "bsp.h"

Q_DEFINE_THIS_MODULE("SmButton")

void sm_button_init(sm_button *me,
                    uint8_t button_id,
                    uint8_t priority,
                    QEvt const **event_queue, uint32_t equeue_size)
{
    me->button_id = button_id;
    me->status = false;
    me->status_bkp = false;

    // 时间事件的构建
    QTimeEvt_ctorX(&me->e_poll, &me->super, ButtonPoll_SIG, 0U);
    QTimeEvt_ctorX(&me->e_time_count, &me->super, TimeCount_SIG, 0U);

    // 活动对象的构建
    QActive_ctor(&me->super, Q_STATE_CAST(&sm_button_initial));
    // 活动对象的启动
    QACTIVE_START(&me->super,
                  priority,
                  event_queue, equeue_size,
                  (void *)0, 0U,
                  (void *)0);
}

/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.9.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${sm::sm_button} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${sm::sm_button} ........................................................*/
/*.${sm::sm_button::SM} ....................................................*/
QState sm_button_initial(sm_button * const me, void const * const par) {
    /*.${sm::sm_button::SM::initial} */
    // Send all time events.
    QTimeEvt_armX(&me->e_poll, 1, 1);
    QTimeEvt_armX(&me->e_time_count, 1, 1);
    return Q_TRAN(&sm_button_work);
}
/*.${sm::sm_button::SM::work} ..............................................*/
QState sm_button_work(sm_button * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${sm::sm_button::SM::work} */
        case Q_ENTRY_SIG: {
            // 初始化
            status_ = Q_HANDLED();
            break;
        }
        /*.${sm::sm_button::SM::work::initial} */
        case Q_INIT_SIG: {
            status_ = Q_TRAN(&sm_button_idle);
            break;
        }
        /*.${sm::sm_button::SM::work::ButtonPoll} */
        case ButtonPoll_SIG: {
            // Get the status of button, and send Evt_Press or Release to the sm_button.
            me->status = button_is_pressed(me->button_id);
            if (me->status == true && me->status_bkp == false)
            {
                QEvt *e = Q_NEW(QEvt, ButtonPressed_SIG);
                QACTIVE_POST(&me->super, e, me);
            }
            else if (me->status == false && me->status_bkp == true)
            {
                QEvt *e = Q_NEW(QEvt, ButtonReleased_SIG);
                QACTIVE_POST(&me->super, e, me);
            }
            me->status_bkp = me->status;
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.${sm::sm_button::SM::work::idle} ........................................*/
QState sm_button_idle(sm_button * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${sm::sm_button::SM::work::idle::ButtonPressed} */
        case ButtonPressed_SIG: {
            // Record the time when the button is pressed.
            me->time_pressed = system_time();
            status_ = Q_TRAN(&sm_button_click);
            break;
        }
        default: {
            status_ = Q_SUPER(&sm_button_work);
            break;
        }
    }
    return status_;
}
/*.${sm::sm_button::SM::work::click} .......................................*/
QState sm_button_click(sm_button * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${sm::sm_button::SM::work::click::ButtonReleased} */
        case ButtonReleased_SIG: {
            // Record the time when the button is released.
            me->time_released = system_time();
            /*.${sm::sm_button::SM::work::click::ButtonReleased::[(system_time()-me->time_pressed~} */
            if ((system_time() - me->time_pressed) <= SM_BUTTON_CLICK_TIME_PRESS) {
                me->time_released = system_time();
                status_ = Q_TRAN(&sm_button_release);
            }
            /*.${sm::sm_button::SM::work::click::ButtonReleased::[else]} */
            else {
                button_event *e = (button_event *)Q_NEW(button_event, ButtonLongPress_SIG);
                e->id = me->button_id;
                e->action = ButtonAction_Click;
                QF_PUBLISH((QEvt *)e, me);
                status_ = Q_TRAN(&sm_button_idle);
            }
            break;
        }
        /*.${sm::sm_button::SM::work::click::TimeCount} */
        case TimeCount_SIG: {
            /*.${sm::sm_button::SM::work::click::TimeCount::[(system_time()-me->time_pressed~} */
            if ((system_time() - me->time_pressed) > SM_BUTTON_CLICK_TIME_PRESS) {
                status_ = Q_TRAN(&sm_button_long_press);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&sm_button_work);
            break;
        }
    }
    return status_;
}
/*.${sm::sm_button::SM::work::release} .....................................*/
QState sm_button_release(sm_button * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${sm::sm_button::SM::work::release::ButtonPressed} */
        case ButtonPressed_SIG: {
            status_ = Q_TRAN(&sm_button_double_click);
            break;
        }
        /*.${sm::sm_button::SM::work::release::TimeCount} */
        case TimeCount_SIG: {
            /*.${sm::sm_button::SM::work::release::TimeCount::[(system_time()-me->time_release~} */
            if ((system_time() - me->time_released) >= SM_BUTTON_CLICK_TIME_RELEASE) {
                button_event *e = (button_event *)Q_NEW(button_event, ButtonClick_SIG);
                e->id = me->button_id;
                e->action = ButtonAction_Click;
                QF_PUBLISH((QEvt *)e, me);
                status_ = Q_TRAN(&sm_button_idle);
            }
            else {
                status_ = Q_UNHANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&sm_button_work);
            break;
        }
    }
    return status_;
}
/*.${sm::sm_button::SM::work::long_press} ..................................*/
QState sm_button_long_press(sm_button * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${sm::sm_button::SM::work::long_press::ButtonReleased} */
        case ButtonReleased_SIG: {
            button_event *e = (button_event *)Q_NEW(button_event, ButtonLongPress_SIG);
            e->id = me->button_id;
            e->action = ButtonAction_LongPress;
            QF_PUBLISH((QEvt *)e, me);
            status_ = Q_TRAN(&sm_button_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&sm_button_work);
            break;
        }
    }
    return status_;
}
/*.${sm::sm_button::SM::work::double_click} ................................*/
QState sm_button_double_click(sm_button * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${sm::sm_button::SM::work::double_click::ButtonReleased} */
        case ButtonReleased_SIG: {
            button_event *e = (button_event *)Q_NEW(button_event, ButtonDoubleClick_SIG);
            e->id = me->button_id;
            e->action = ButtonAction_DoubleClick;
            QF_PUBLISH((QEvt *)e, me);
            status_ = Q_TRAN(&sm_button_idle);
            break;
        }
        default: {
            status_ = Q_SUPER(&sm_button_work);
            break;
        }
    }
    return status_;
}
/*.$enddef${sm::sm_button} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
